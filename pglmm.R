# Simulate phylogenetic LMM with repeated measurements

library(tidyverse)
library(easystats)
library(ape)
library(brms)
#library(MASS) # for multivariate gaussian

# Parameters
set.seed(123)
n_species <- 10
measurements_per_species <- 10

# Create phylogeny and covariance matrix
## The diagonals of the cov matrix are the total branch lengths from the root to tips for each species
## The off-diagonals are the total branch lengths from the root to the most recent common ancestor (MRCA) of two species
phylo <- rtree(n = n_species)
phylo <- chronopl(phylo, lambda = 1) # turn the genetic distance based tree to a time calibrated tree
species <- phylo$tip.label
plot(phylo, main = "Mock Phylogeny")
phylo_cov <- vcv(phylo)
#cov_scaled <- phylo_cov/sum(diag(phylo_cov)) # rescaled the cov to have a total variance = 1

# Simulate phylogenetic effects
# mvrnorm: Simulate from a Multivariate Normal Distribution
phylo_effects <- MASS::mvrnorm(n = 1, mu = rep(0, nrow(phylo_cov)), Sigma = phylo_cov)
names(phylo_effects) <- species
#apply(phylo_effects, 2, var) %>% sum # this should be close to 1 if n = 1000 in m

# Simulate species effect
sp_group <- rep(species, each = measurements_per_species)
species_effects <- rnorm(n_species, 0, 1)
names(species_effects) <- species

# Simulate response in negative binomial
X <- rnorm(n_species*measurements_per_species, 0, 1) # predictor
eta <- 1 + 0.8 * X + phylo_effects[sp_group] + 0.1*species_effects[sp_group]
# Set a high dispersion parameter to reduce randomness generated by NB sampling
Y <- rnbinom(n_species * measurements_per_species, mu = exp(eta), size = 100) # dispersion parameter k. var(NB) = mu + mu^2/k

tb <- tibble(species = sp_group, phylo = sp_group, X = X, Y = Y)
hist(Y, breaks = 50)

# species mean
tb <- tb %>%
    group_by(phylo) %>%
    mutate(X_bet = mean(X), X_wit = X - X_bet)


# First model using the species mean ----
mod <- brm(
    Y ~ X_bet + X_wit + (1|species) + (1|gr(phylo, cov = phylo_cov)),
    data = tb,
    family = "negbinomial2",
    data2 = list(phylo_cov = phylo_cov),
    chains = 4, cores = 4, iter = 20000, thin = 10, seed = 123,
    control = list(adapt_delta = 0.99)
)

pp_check(mod)
describe_posterior(mod)

# phylogenetic signal
# In NB, there is a sigma estimate to describe variability beyond poisson (which equals mean)
hyp <- hypothesis(mod, class = NULL, "sd_phylo__Intercept^2 / (sd_phylo__Intercept^2 + sd_species__Intercept^2 + sigma^2) = 0")
plot(hyp)

hyp <- hypothesis(mod, class = NULL, "sd_species__Intercept^2 / (sd_phylo__Intercept^2 + sd_species__Intercept^2 + sigma^2) = 0")
plot(hyp)

# Variance components
set.seed(1)
pp <- posterior_predict(mod)
pp_mean <- colMeans(pp) # mean posterior predictor
var_res <- var(Y - pp_mean)

## Proportion of total variance explained not by residual
1 - var_res / var(Y) # should be similar to bayes R2
bayes_R2(mod)

## variance explained by random effects (phylogeny)
pp <- as_draws_df(mod) %>% as_tibble()
ran_samples_phylo <- select(pp, starts_with("r_phylo"))
ran_samples_sp <- select(pp, starts_with("r_species"))
var_ran_phylo <- apply(ran_samples_phylo, 1, var) # posterior distribution of variance of random effects
var_ran_sp <- apply(ran_samples_sp, 1, var) # posterior distribution of variance of random effects

var_tot <- var_ran_phylo + var_ran_sp + pp$sigma^2 # total variance
ps <- var_ran_phylo / var_tot
hist(ps); mean(ps); quantile(ps, c(0.05, 0.5, 0.95)) # this should be similar to hypothesis results

# Second model using the raw values ----
mod2 <- brm(
    Y ~ X + (1|species) + (1|gr(phylo, cov = phylo_cov)),
    data = tb,
    family = "negbinomial2",
    data2 = list(phylo_cov = phylo_cov),
    chains = 4, cores = 4, iter = 20000, thin = 10, seed = 123,
    control = list(adapt_delta = 0.99)
)

pp_check(mod2)
describe_posterior(mod2)

# In NB, there is a sigma estimate to describe variability beyond poisson (which equals mean)
hyp <- hypothesis(mod2, class = NULL, "sd_phylo__Intercept^2 / (sd_phylo__Intercept^2 + sd_species__Intercept^2 + sigma^2) = 0")
plot(hyp)
