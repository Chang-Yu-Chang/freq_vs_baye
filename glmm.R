#' Compare glmm between glmmTMB and brms. Repeated measurement per species
#' Simulate
#' 0. linear
#' 1. logistic
#' 2. poisson
#' 3. negative binomial
#' 4. zero inflated negative binomial, constant inflation
#' 5. zero inflated negative binomial, constant inflation

library(tidyverse)
library(easystats)
library(glmmTMB)
library(brms)

# Simulation ----
set.seed(123)
n_species <- 10
measurements_per_species <- 20
n_total <- n_species*measurements_per_species
species <- paste0("species", 1:n_species)
sp_group <- rep(species, each = measurements_per_species)

# Species effect
species_effects <- rnorm(n_species, 0, 1)
names(species_effects) <- species
var(species_effects)

## Predictor
X <- rnorm(n_total, 0, 1) # predictor
eta <- 1 + 0.8 * X + species_effects[sp_group] # Linear predictor

## 0. Linear
Y <- eta + rnorm(n_total, 0, 1) # sigma

## 1. Logistic / Bernoulli. The link function is logistic
Y1 <- rbinom(n_total, 1, plogis(eta))

## 2. Poisson
Y2 <- rpois(n_total, lambda = exp(eta))

## 3. Negative binomial
# Set a high dispersion parameter to reduce randomness generated by NB sampling
k = 10 # dispersion parameter k. var(NB) = mu + mu^2/k
Y3 <- rnbinom(n_total, mu = exp(eta), size = k)

## 4. Zero-inflated poisson
p_zero <- 0.2 # probability of zero inflation
inflate <- rbinom(n_total, size = 1, prob = p_zero)
counts <- rpois(n_total, lambda = exp(eta))
Y4 <- counts*inflate

## 5. Zero-inflated negative binomial
counts <- rnbinom(n_total, mu = exp(eta), size = k)
Y5 <- counts * inflate

##
tb <- tibble(X = X, Y = Y, Y1 = Y1, Y2 = Y2, Y3 = Y3, Y4 = Y4, Y5 = Y5)
tb %>%
    pivot_longer(-X) %>%
    ggplot() +
    geom_histogram(aes(x = value)) +
    facet_wrap(~name, scales = "free") +
    theme_bw()




# Simulate response ----
## Predictor
X <- rnorm(n_total, 0, 1) # predictor

## Linear predictor
eta <- 1 + 0.8 * X + species_effects[sp_group]

## 0. Linear
Y <- eta + rnorm(n_total, 0, 1) # sigma

## 1. Logistic / Bernoulli. The link function is logistic
Y1 <- rbinom(n_total, 1, plogis(eta))

## 2. Poisson
Y2 <- rpois(n_total, lambda = exp(eta))

## 3. Negative binomial
# Set a high dispersion parameter to reduce randomness generated by NB sampling
Y3 <- rnbinom(n_total, mu = exp(eta), size = 100) # dispersion parameter k. var(NB) = mu + mu^2/k

## 4. Zero-inflated negative binomial
n <- 10        # number of trials in binomial
q <- 0.3       # success probability in binomial
p_zero <- 0.2 # probability of zero inflation

# Number of observations
n_obs <- 1000

# Simulate zero-inflation Bernoulli
inflate <- rbinom(n_obs, size = 1, prob = p_zero)

# Simulate binomial counts
counts <- rbinom(n_obs, size = n, prob = q)

# Apply zero inflation
zib_samples <- ifelse(inflate == 1, 0, counts)

## Table
tb <- tibble(species = sp_group, phylo = sp_group, X = X, Y = Y, Y1 = Y1, Y2 = Y2, Y3 = Y3) %>%
    # species mean
    group_by(phylo) %>%
    mutate(X_bet = mean(X), X_wit = X - X_bet)
hist(Y, breaks = 50)
hist(Y1, breaks = 50)
hist(Y2, breaks = 50)
hist(Y3, breaks = 50)








# Simulate data with a poisson distribution ----
set.seed(123)
n_groups <- 10
n_per_group <- 100
group <- factor(rep(1:n_groups, each = n_per_group))
X <- rep(rnorm(n_per_group, 0, 1), n_groups)

# Random effect, group effect
b_count <- rnorm(n_groups, 0, 1)
re_count <- b_count[group]

# Linear predictor
# for poisson: log(lambda) = eta = beta * X. lambda = exp(eta)
# for nbinom: log(mu) = eta = beta * X. mu = exp(eta)
eta <- 0.01 + 0.08 * X + re_count
Y <- rpois(n_groups*n_per_group, lambda = exp(eta))
tb <- tibble(Y, X, eta, group)
hist(Y, breaks = 100)

# Frequentist ----
mod <- glmmTMB(Y ~ X + (1|group), family = poisson, data = tb)
summary(mod)

# Residual at the response scale
var(resid(mod, type = "response"))
var(Y - predict(mod, type = "response"))

## Pearson residual = (y - y_hat) / sqrt(var(y_hat))
var(resid(mod, type = "pearson"))
lambda_hat <- predict(mod, type = "response")
var((Y - lambda_hat) / sqrt(lambda_hat)) # poisson has same mean and variance

# Random effects
summary(mod)
VarCorr(mod)[[1]][[1]][1] # Model based theoretical estimate of the entire random effect distribution
as_tibble(ranef(mod))[["condval"]] %>% var # Empirical BLUPs (Best Linear Unbiased Predictors) for each group


# Variance on the response scale
## Total variance minus those explained by residuals
var_res <- var(Y - predict(mod, type = "response")) # residual variance. it's build in poisson
var_tot <- var(Y) # total variance
1 - var_res/var_tot

## Variance explined by random effect
var_ran <- VarCorr(mod)[[1]][[1]][1] # Model based theoretical estimate of the entire random effect distribution
var_ran / var_tot



# Bayesian ----
mod2 <- brm(Y ~ X + (1|group), data = tb, family = poisson, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123)

# Fixed effect estimates
fixef(mod2)

# Posterior predictive checks
pp_check(mod2)

# Compute Bayesian R2
bayes_R2(mod2)

# Variance components
set.seed(1)
pp <- posterior_predict(mod2)
pp_mean <- colMeans(pp) # mean posterior predictor
var_res2 <- var(Y - pp_mean)

## Proportion of total variance explained not by residual
1 - var_res2 / var(Y) # should be similar to bayes R2

## variance explained by random effects
ran_samples <- as_draws_df(mod2) %>%
    as_tibble() %>%
    select(starts_with("r_group"))

apply(ran_samples, 2, mean) # group effect averaged over posterior samples
ranef(mod2)$group[,,1]

var_ran <- apply(ran_samples, 1, var) # posterior distribution of variance of random effects
(var_ran / var_tot) %>% hist
mean(var_ran / var_tot)
