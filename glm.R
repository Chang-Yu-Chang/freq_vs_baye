#' Compare glm between glmmTMB and brms
#' Simulate
#' 0. linear
#' 1. logistic
#' 2. poisson
#' 3. negative binomial
#' 4. zero inflated poisson
#' 5. zero inflated negative binomial

library(tidyverse)
library(easystats)
library(glmmTMB)
library(brms)

# Simulation ----
set.seed(123)
n_total <- 200

## Predictor
X <- rnorm(n_total, 0, 1) # predictor
eta <- 1 + 0.8 * X # Linear predictor

## 0. Linear
Y <- eta + rnorm(n_total, 0, 1) # sigma

## 1. Logistic / Bernoulli. The link function is logistic
Y1 <- rbinom(n_total, 1, plogis(eta))

## 2. Poisson
Y2 <- rpois(n_total, lambda = exp(eta))

## 3. Negative binomial
# Set a high dispersion parameter to reduce randomness generated by NB sampling
k = 10 # dispersion parameter k. var(NB) = mu + mu^2/k
Y3 <- rnbinom(n_total, mu = exp(eta), size = k)

## 4. Zero-inflated poisson
p_zero <- 0.2 # probability of zero inflation
inflate <- rbinom(n_total, size = 1, prob = 1-p_zero)
counts <- rpois(n_total, lambda = exp(eta))
Y4 <- counts*inflate

## 5. Zero-inflated negative binomial
counts <- rnbinom(n_total, mu = exp(eta), size = k)
Y5 <- counts * inflate

##
tb <- tibble(X = X, Y = Y, Y1 = Y1, Y2 = Y2, Y3 = Y3, Y4 = Y4, Y5 = Y5)
tb %>%
    pivot_longer(-X) %>%
    ggplot() +
    geom_histogram(aes(x = value)) +
    facet_wrap(~name, scales = "free") +
    theme_bw()

# Examples on NB ----
## Frequentist
mod3 <- glmmTMB(Y3 ~ X, data = tb, family = nbinom2)
summary(mod3)

# Prediction at the resposne scale. There are three ways to do it
predict(mod3, type = "link") # prediction at the latent scale
exp(predict(mod3)) # predict at the latent scale and apply the link function
fitted(mod3) # predicted at the response scale
predict(mod3, type = "response") # predicted at the response scale

# Residuals. Two ways to do it
resid(mod3)
Y3 - exp(predict(mod3)) # residual is at the latent scale

# pseudo R2. This assumes that the residuals are normally distributed
## Based on variance of residuals that reduce the explanation of total variance
var_res <- var(Y3 - predict(mod3, type = "response")) # residual variance at the response scale
var_tot <- var(Y3) # total variance in the observation
1 - var_res/var_tot

## Bayesian
mod3_baye <- brm(Y3 ~ X, data = tb, family = negbinomial, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
pp_check(mod3_baye) # posterior prediction checks
as_draws_df(mod3_baye)$shape %>% mean # estimated dispersion parameter

# Variance components
pfit <- posterior_epred(mod3_baye) # fitted values (mu)
var_fit_samples <- apply(pfit, 1, var) # variance of fitted values (mu) across samples per draw
shapes <- as_draws_df(mod3_baye)$shape # Estimated shape (k) parameter
var_res_samples <- map_dbl(1:nrow(pfit), function(i) (mean(pfit[i,] + pfit[i,]^2/shapes[i]))) # NB variance = mu + mu^2 / k per data point per draw. Average across data point to get it per draw
quantile(var_fit_samples / ( var_fit_samples + var_res_samples), c(0.05, 0.5, 0.95)) # this should be the same as bayes R2
bayes_R2(mod3_baye) # Compute Bayesian R2

# Frequenstist ----
tb_freq <- tibble(name = paste0("Y", c("", 1:5)), mod = rep(list(NA), 6))

tb_freq$mod[[1]] <- glmmTMB(Y ~ X, data = tb, family = gaussian)
tb_freq$mod[[2]] <- glmmTMB(Y1 ~ X, data = tb, family = bernoulli)
tb_freq$mod[[3]] <- glmmTMB(Y2 ~ X, data = tb, family = poisson)
tb_freq$mod[[4]] <- glmmTMB(Y3 ~ X, data = tb, family = nbinom2)
tb_freq$mod[[5]] <- glmmTMB(Y4 ~ X, data = tb, family = poisson, ziformula = ~1)
tb_freq$mod[[6]] <- glmmTMB(Y5 ~ X, data = tb, family = nbinom2, ziformula = ~1)

# Manually compute vairance based R2
## Gaussian. var(fit) / (var(fit) + sigma^2)
var_fit <- var(fitted(tb_freq$mod[[1]]))
var_fit / (var_fit + sigma(tb_freq$mod[[1]])^2)
r2(tb_freq$mod[[1]])

## Logistic. p(1-p)
p <- fitted(tb_freq$mod[[2]])
mean(p * (1-p))
r2(tb_freq$mod[[2]])

## Poisson. var(poi) = mean(mu)
# var_fit <- var(predict(tb_freq$mod[[3]], type = "link"))
# var_res <- mean(predict(tb_freq$mod[[3]], type = "response"))
# var_fit / (var_fit + var_res)
# 1 - var(residuals(tb_freq$mod[[3]], type = "response")) / var(tb$Y3)
r2(tb_freq$mod[[3]]) # pseudo-RÂ²

## Negative binomial
# var_fit <- var(fitted(tb_freq$mod[[4]]))
# shape <- sigma(tb_freq$mod[[4]]) # this is the shape parameter, not sigma per se
# mu <- mean(fitted(tb_freq$mod[[4]]))
# var_nb <- mu + mu^2/shape
# var_fit / (var_fit + var_nb)
r2(tb_freq$mod[[4]])

## ZIP
r2(tb_freq$mod[[5]])
z <- fixef(tb_freq$mod[[5]])[[2]][[1]] # estimated zi parameter
exp(z) / (1+exp(z)) # estimated probability of structural zeros in the

## ZINB
r2(tb_freq$mod[[6]])
z <- fixef(tb_freq$mod[[6]])[[2]][[1]] # estimated zi parameter
exp(z) / (1+exp(z)) # estimated probability of structural zeros in the


# Bayesian ----
tb_baye <- tibble(name = paste0("Y", c("", 1:5)), mod = rep(list(NA), 6))
tb_baye$mod[[1]] <- brm(Y ~ X, data = tb, family = gaussian, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
tb_baye$mod[[2]] <- brm(Y1 ~ X, data = tb, family = bernoulli, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
tb_baye$mod[[3]] <- brm(Y2 ~ X, data = tb, family = poisson, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
tb_baye$mod[[4]] <- brm(Y3 ~ X, data = tb, family = negbinomial, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
tb_baye$mod[[5]] <- brm(bf(Y4 ~ X, zi ~ 1), data = tb, family = zero_inflated_poisson, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))
tb_baye$mod[[6]] <- brm(bf(Y5 ~ X, zi ~ 1), data = tb, family = zero_inflated_negbinomial, chains = 2, cores = 2, iter = 10000, thin = 10, seed = 123, control = list(adapt_delta = 0.95))

# Variance and bayesian R2, which is computed at the latent scale
## Gaussian
pp_check(tb_baye$mod[[1]])
var_fit_samples <- apply(posterior_epred(tb_baye$mod[[1]]), 1, var)
var_res_samples <- as_draws_df(tb_baye$mod[[1]])$sigma^2
quantile(var_fit_samples / (var_fit_samples + var_res_samples), c(0.05, 0.5, 0.95))
bayes_R2(tb_baye$mod[[1]])

## Logistic
# pfit <- posterior_linpred(tb_baye$mod[[2]], transform = F) # linear predictor
# var_fit_samples <- apply(pfit, 1, var)
# var_res_samples <- pi^2 / 3 # theoretical residual variance of logistic regression
# quantile(var_fit_samples / ( var_fit_samples + var_res_samples), c(0.05, 0.5, 0.95))
pp_check(tb_baye$mod[[2]])
bayes_R2(tb_baye$mod[[2]])

## Poisson
# pfit <- posterior_epred(tb_baye$mod[[3]]) # at the response scale
# res <- pfit - apply(pfit, 1, mean)
# var_res_samples <- apply(res, 1, var)
# quantile(1 - var_res_samples/var(tb$Y2), c(0.05, 0.5, 0.95)) # ok I give up. it's
pp_check(tb_baye$mod[[3]])
bayes_R2(tb_baye$mod[[3]])

## Negative binomial
pp_check(tb_baye$mod[[4]])
as_draws_df(tb_baye$mod[[4]])$shape %>% mean # estimated dispersion parameter
bayes_R2(tb_baye$mod[[4]])

## ZIP
pp_check(tb_baye$mod[[5]])
tb_baye$mod[[5]]
z <- as_draws_df(tb_baye$mod[[5]])$Intercept_zi
(exp(z) / (1+exp(z))) %>% mean # probability of an observation to be structurally zero
bayes_R2(tb_baye$mod[[5]])

## ZINB
pp_check(tb_baye$mod[[6]])
tb_baye$mod[[6]]
as_draws_df(tb_baye$mod[[6]])$shape %>% mean # estimated dispersion parameter
z <- as_draws_df(tb_baye$mod[[6]])$Intercept_zi
(exp(z) / (1+exp(z))) %>% mean # probability of an observation to be structurally zero
bayes_R2(tb_baye$mod[[6]])
